// Prim Algorithm
void prim(){
  T = Ø;
  W = Ø;
  E로부터 최소 비용인 간선 {v,w}를 선택;
  while (T는 n-1개 이하의 간선을 포함 && E는 공집합이 아님){
    E에서 간선 {v,w}를 제거;
    if ({v,w}가 T 내에서 사이클을 생성 안함){
      T = T ∪ {{v,w}}; //선택한 간선 추가
      W = W ∪ {{v,w}}; //선택한 정점 추가
    }
    else 간선 {v,w}를 버림;
    E로부터 W내의 정점과 최소 비용으로 연결된 간선 {v,w}를 선택;
  }
} 
  
// Kruskal Algorithm
void kruskal(){
  while (T가 n-1개보다 적은 간선을 포함하고 E가 공집합이 아님){
    E로부터 최소 비용인 간선 {v,w}를 선택;
    E에서 간선 {v,w}를 제거;
    if ({v,w}가 T내에서 사이클을 생성 안함)
      T = T ∪ {{v,w}};
    else
      간선 {v,w}를 버림;
  }
}

//Sollin Algorithm
void sollin(){
# 집합 E의 초기 상태는 주어진 그래프의 간선 집합
# 집합 F의 초기 상태는 그래프의 모든 정점들로 구성된 간선이 없는 숲

  T = Ø;
    while(T는 완전한 하나의 트리가 아니고 E는 공집합이 아님){
      for (F내의 각각의 트리 T에 대하여){
        T와 다른 트리를 연결하는 E의 간선 중에서 최소비용 간선 {v,w}를 선택;
        T = T ∪ {{v,w}};
        E에서 간선 {v,w}를 제거;
        }
        T에 새로 추가된 간선을 포함하여 F를 수정;
      }
}
